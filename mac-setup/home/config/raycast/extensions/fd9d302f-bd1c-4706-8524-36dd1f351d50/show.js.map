{
  "version": 3,
  "sources": ["../src/show.tsx", "../node_modules/run-applescript/index.js", "../src/storage.api.ts"],
  "sourcesContent": ["import {\n  Action,\n  ActionPanel,\n  Alert,\n  closeMainWindow,\n  confirmAlert,\n  getPreferenceValues,\n  Icon,\n  List,\n  showHUD,\n} from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport { runAppleScript } from \"run-applescript\";\nimport { getConnections, saveConnections } from \"./storage.api\";\nimport { ISSHConnection } from \"./types\";\n\ninterface Preferences {\n  terminal: string;\n  openin: string;\n  onlyname: boolean;\n}\n\nconst preferences = getPreferenceValues<Preferences>();\nexport const terminal = preferences[\"terminal\"];\nexport const openIn = preferences[\"openin\"];\nexport const onlyName = preferences[\"onlyname\"];\n\nasync function runTerminal(item: ISSHConnection) {\n  let command;\n  if (onlyName) {\n    const name = item.name;\n    command = [\"ssh\", name].join(\" \");\n  } else {\n    let identity = \"\";\n    if (item.sshKey) {\n      identity = `-i ${item.sshKey} `;\n    }\n    let customPort = \"\";\n    if (item.port) {\n      customPort = `-p ${item.port} `;\n    }\n    let customCommand = \"\";\n    let interactive = \"\";\n    if (item.command) {\n      customCommand = `\\\\\"${item.command}\\\\\" `;\n      interactive = \"-t\";\n    }\n    let address = item.address;\n    if (item.user) {\n      address = `${encodeURIComponent(item.user)}@${address}`;\n    }\n    command = [\"ssh\", interactive, identity, address, customPort, customCommand].filter(Boolean).join(\" \");\n  }\n\n  const scriptWarp = `\n      -- For the latest version:\n      -- https://github.com/DavidMChan/custom-alfred-warp-scripts\n\n      -- Set this property to true to always open in a new window\n      property open_in_new_window : ${openIn == \"newWindow\"}\n\n      -- Set this property to true to always open in a new tab\n      property open_in_new_tab : ${openIn == \"newTab\"}\n\n      -- Don't change this :)\n      property opened_new_window : false\n\n      -- Handlers\n      on new_window()\n          tell application \"System Events\" to tell process \"Warp\"\n              click menu item \"New Window\" of menu \"File\" of menu bar 1\n              set frontmost to true\n          end tell\n          delay 0.5\n      end new_window\n\n      on new_tab()\n          tell application \"System Events\" to tell process \"Warp\"\n              click menu item \"New Tab\" of menu \"File\" of menu bar 1\n              set frontmost to true\n          end tell\n      end new_tab\n\n      on call_forward()\n          tell application \"Warp\" to activate\n      end call_forward\n\n      on is_running()\n          application \"Warp\" is running\n      end is_running\n\n      on has_windows()\n          if not is_running() then return false\n          tell application \"System Events\"\n              if windows of process \"Warp\" is {} then return false\n          end tell\n          true\n      end has_windows\n\n      on send_text(custom_text)\n          tell application \"System Events\"\n              keystroke custom_text\n          end tell\n      end send_text\n\n\n      -- Main\n      if not is_running() then\n          call_forward()\n          set opened_new_window to true\n      else\n          call_forward()\n          set opened_new_window to false\n      end if\n\n      if has_windows() then\n          if open_in_new_window and not opened_new_window then\n              new_window()\n          else if open_in_new_tab and not opened_new_window then\n              new_tab()\n          end if\n      else\n          new_window()\n      end if\n\n\n      -- Make sure a window exists before we continue, or the write may fail\n      repeat until has_windows()\n          delay 0.5\n      end repeat\n      delay 0.5\n\n      send_text(\"${command}\")\n      call_forward()\n  `;\n  const scriptTerminal = `\n    tell application \"Terminal\"\n      do script \"\"\n      activate\n      set position of front window to {1, 1}\n      set shell to do script \"${command}\" in window 1\n    end tell\n\n    tell application \"System Events\" to tell process \"Terminal\"\n        set frontmost to true\n        windows where title contains \"bash\"\n        if result is not {} then perform action \"AXRaise\" of item 1 of result\n    end tell\n  `;\n  const scriptIterm = `\n    -- Set this property to true to open in a new window instead of a new tab\n      property open_in_new_window : ${openIn == \"newWindow\"}\n\n    on new_window()\n    \ttell application \"iTerm\" to create window with default profile\n    end new_window\n\n    on new_tab()\n    \ttell application \"iTerm\" to tell the first window to create tab with default profile\n    end new_tab\n\n    on call_forward()\n    \ttell application \"iTerm\" to activate\n    end call_forward\n\n    on is_running()\n    \tapplication \"iTerm\" is running\n    end is_running\n\n    on is_processing()\n    \ttell application \"iTerm\" to tell the first window to tell current session to get is processing\n    end is_processing\n\n    on has_windows()\n    \tif not is_running() then return false\n    \tif windows of application \"iTerm\" is {} then return false\n    \ttrue\n    end has_windows\n\n    on send_text(custom_text)\n    \ttell application \"iTerm\" to tell the first window to tell current session to write text custom_text\n    end send_text\n\n    -- Main\n    if has_windows() then\n      if open_in_new_window then\n        new_window()\n      else\n        new_tab()\n      end if\n    else\n    \t-- If iTerm is not running and we tell it to create a new window, we get two\n    \t-- One from opening the application, and the other from the command\n    \tif is_running() then\n    \t\tnew_window()\n    \telse\n    \t\tcall_forward()\n    \tend if\n    end if\n\n    -- Make sure a window exists before we continue, or the write may fail\n    repeat until has_windows()\n    \tdelay 0.01\n    end repeat\n\n    send_text(\"${command}\")\n    call_forward()\n  `;\n\n  const scriptAlacritty = `\n  -- Set this property to true to always open in a new window\n  property open_in_new_window : ${openIn == \"newWindow\"}\n\n  -- Set this property to true to always open in a new tab\n  property open_in_new_tab : ${openIn == \"newTab\"}\n\n  -- Don't change this :)\n  property opened_new_window : false\n\n  -- Handlers\n  on new_window()\n      tell application \"Alacritty\"\n          activate\n          delay 0.5\n          tell application \"System Events\" to tell process \"Alacritty\"\n              keystroke \"n\" using {command down}\n          end tell\n      end tell\n      delay 0.5\n  end new_window\n\n  on new_tab()\n      tell application \"Alacritty\"\n          activate\n          tell application \"System Events\" to tell process \"Alacritty\"\n              keystroke \"t\" using {command down}\n          end tell\n      end tell\n      delay 0.5\n  end new_tab\n\n  on call_forward()\n      tell application \"Alacritty\" to activate\n      tell application \"Alacritty\" to reopen\n  end call_forward\n\n  on is_running()\n      application \"Alacritty\" is running\n  end is_running\n\n  on has_windows()\n      if not is_running() then return false\n      tell application \"System Events\"\n          if windows of process \"Alacritty\" is {} then return false\n      end tell\n      true\n  end has_windows\n\n  on send_text(custom_text)\n      tell application \"System Events\" to tell process \"Alacritty\"\n          keystroke custom_text\n      end tell\n  end send_text\n\n\n  -- Main\n  if not is_running() then\n      call_forward()\n      set opened_new_window to true\n  else\n      call_forward()\n      set opened_new_window to false\n  end if\n\n  if not has_windows() then\n    tell application \"Alacritty\" to reopen\n    delay 0.2\n    tell application \"Alacritty\" to activate\n  end if\n\n  if open_in_new_window and not opened_new_window then\n      new_window()\n  else if open_in_new_tab and not opened_new_window then\n      new_tab()\n  end if\n\n\n  -- Make sure a window exists before we continue, or the write may fail\n  repeat until has_windows()\n      delay 0.5\n  end repeat\n  delay 0.5\n  send_text(\"${command}\n\") -- Enter at the end of string\n  call_forward()\n  `;\n\n  const scriptHyper = `\n  -- Set this property to true to open in a new window instead of a new tab\n  property open_in_new_window : ${openIn == \"newWindow\"}\n\n  on new_window()\n      tell application \"System Events\" \n          launch application \"Hyper\"\n      end tell\n  end new_window\n\n  on new_tab()\n      tell application \"System Events\"\n          -- Check if Hyper is already running\n          set isRunning to (exists process \"Hyper\")\n\n          if isRunning then\n              -- If Hyper is running, bring it to the front and open a new tab\n              tell application \"Hyper\" to activate\n              tell application \"System Events\" to keystroke \"t\" using command down\n          else\n              -- If Hyper isn't running, launch it\n              launch application \"Hyper\"\n          end if\n      end tell\n  end new_tab\n\n  on call_forward()\n      tell application \"Hyper\" to activate\n  end call_forward\n\n  on is_running()\n      application \"Hyper\" is running\n  end is_running\n\n  -- Hyper doesn't have a direct equivalent to 'is processing', so we'll assume it's ready if it's running\n  on is_processing()\n      is_running()\n  end is_processing\n\n  on has_windows()\n      if not is_running() then return false\n      -- Hyper always has at least one window, so we'll just check if it's running\n      true\n  end has_windows\n\n  on send_text(custom_text)\n      tell application \"System Events\"\n          keystroke custom_text & return\n      end tell\n  end send_text\n\n  -- Main\n  if has_windows() then\n      if open_in_new_window then\n          new_window()\n      else\n          new_tab()\n      end if\n  else\n      -- If Hyper is not running and we tell it to create a new window, we get two\n      -- One from opening the application, and the other from the command\n      if is_running() then\n          new_window()\n      else\n          call_forward()\n      end if\n  end if \n\n\n  -- Give Hyper some time to load \n  repeat until has_windows()\n      delay 0.5\n  end repeat\n  delay 0.5\n\n  send_text(\"${command}\")\n  call_forward()\n  `;\n\n  if (terminal == \"iTerm\") {\n    try {\n      await runAppleScript(scriptIterm);\n    } catch (error) {\n      await runAppleScript(scriptTerminal);\n      console.log(error);\n    }\n  } else if (terminal == \"Warp\") {\n    try {\n      await runAppleScript(scriptWarp);\n    } catch (error) {\n      await runAppleScript(scriptTerminal);\n      console.log(error);\n    }\n  } else if (terminal == \"Alacritty\") {\n    try {\n      await closeMainWindow(); // neccessary when alacritty already in fullscreen\n      await runAppleScript(scriptAlacritty);\n    } catch (error) {\n      await runAppleScript(scriptTerminal);\n      console.log(error);\n    }\n  } else if (terminal == \"Hyper\") {\n    try {\n      await runAppleScript(scriptHyper);\n    } catch (error) {\n      await runAppleScript(scriptTerminal);\n      console.log(error);\n    }\n  } else {\n    await runAppleScript(scriptTerminal);\n  }\n\n  await showHUD(`\u2705 Connection [${item.name}] opened with [${terminal}].`);\n}\n\nfunction getConnectionString(item: ISSHConnection) {\n  if (onlyName) {\n    return item.name;\n  }\n\n  const parts = [];\n  if (item.sshKey) parts.push(`-i ${item.sshKey}`);\n  if (item.port) parts.push(`-p ${item.port}`);\n  if (item.command) parts.push(`\"${item.command}\"`);\n\n  const address = item.user ? `${item.user}@${item.address}` : item.address;\n  parts.unshift(\"ssh\", address);\n\n  return parts.filter(Boolean).join(\" \");\n}\n\nexport default function Command() {\n  const [connectionsList, setConnectionsList] = useState<ISSHConnection[]>([]);\n  const [loading, setLoading] = useState<boolean>(true);\n\n  useEffect(() => {\n    (async () => {\n      setLoading(true);\n\n      const items: ISSHConnection[] = await getConnections();\n\n      setConnectionsList(items);\n      setLoading(false);\n    })();\n  }, []);\n\n  async function removeItem(item: ISSHConnection) {\n    const confirmed = await confirmAlert({\n      title: \"Remove Connection\",\n      message: `Are you sure you want to remove connection [${item.name}]?`,\n      primaryAction: {\n        title: \"Remove\",\n        style: Alert.ActionStyle.Destructive,\n      },\n      dismissAction: {\n        title: \"Cancel\",\n      },\n    });\n    if (confirmed) {\n      let items: ISSHConnection[] = await getConnections();\n      items = items.filter((i) => i.id !== item.id);\n\n      await saveConnections(items);\n      setConnectionsList(items);\n      await showHUD(`\uD83D\uDDD1 Connection [${item.name}] removed!`);\n    }\n  }\n\n  return (\n    <List isLoading={loading}>\n      {connectionsList.map((item) => {\n        return (\n          <List.Item\n            actions={<GetAction item={item} onItemRemove={removeItem} />}\n            id={item.id}\n            key={item.name}\n            title={item.name}\n            subtitle={getSubtitle(item)}\n          />\n        );\n      })}\n    </List>\n  );\n}\n\nfunction GetAction({\n  item,\n  onItemRemove,\n}: {\n  item: ISSHConnection;\n  onItemRemove: (item: ISSHConnection) => Promise<void>;\n}) {\n  const itemString = getConnectionString(item);\n  return (\n    <ActionPanel>\n      <ActionPanel.Section title=\"Operations\">\n        <Action icon={Icon.Terminal} title=\"Open Connection\" onAction={() => runTerminal(item)} />\n        <Action.CopyToClipboard\n          title=\"Copy Connection String\"\n          content={itemString}\n          shortcut={{ modifiers: [\"cmd\"], key: \"c\" }}\n        />\n        <Action.Paste\n          icon={Icon.Text}\n          title=\"Paste Connection String\"\n          content={itemString}\n          shortcut={{ modifiers: [\"cmd\"], key: \"v\" }}\n          onPaste={() => showHUD(`\uD83D\uDCDD Pasting conn. [${item.name}] to active app`)}\n        />\n      </ActionPanel.Section>\n      <ActionPanel.Section title=\"Danger zone\">\n        <Action\n          title=\"Remove Connection\"\n          icon={Icon.Trash}\n          style={Action.Style.Destructive}\n          onAction={() => onItemRemove(item)}\n          shortcut={{ modifiers: [\"ctrl\"], key: \"x\" }}\n        />\n      </ActionPanel.Section>\n    </ActionPanel>\n  );\n}\n\nfunction getSubtitle(item: ISSHConnection) {\n  return `${item.user ? item.user + \"@\" : \"\"}${item.address}${item.port ? \" Port: \" + item.port : \"\"}${\n    item.sshKey ? \" SSH Key: \" + item.sshKey : \"\"\n  } ${item.command ? ' Command: \"' + item.command + '\"' : \"\"}`;\n}\n", "import process from 'node:process';\nimport {promisify} from 'node:util';\nimport {execFile, execFileSync} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\nexport async function runAppleScript(script, {humanReadableOutput = true} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst {stdout} = await execFileAsync('osascript', ['-e', script, outputArguments]);\n\treturn stdout.trim();\n}\n\nexport function runAppleScriptSync(script, {humanReadableOutput = true} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst stdout = execFileSync('osascript', ['-e', script, ...outputArguments], {\n\t\tencoding: 'utf8',\n\t\tstdio: ['ignore', 'pipe', 'ignore'],\n\t\ttimeout: 500,\n\t});\n\n\treturn stdout.trim();\n}\n", "import { LocalStorage, getPreferenceValues } from \"@raycast/api\";\nimport { ISSHConnection } from \"./types\";\nimport * as fs from \"fs\";\n\nconst preferences = getPreferenceValues();\nconst sshConfig = preferences.sshConfig.replace(\"~\", process.env.HOME);\n\nfunction parseSSHConfig(configFilePath: string): ISSHConnection[] {\n  const configData = fs.readFileSync(configFilePath, \"utf8\");\n  const configLines = configData.split(\"\\n\");\n\n  const connections: ISSHConnection[] = [];\n  let currentConnection: ISSHConnection | null = null;\n\n  for (const line of configLines) {\n    const trimmedLine = line.trim();\n\n    if (trimmedLine.startsWith(\"#\") || trimmedLine === \"\") {\n      continue;\n    }\n\n    if (trimmedLine.startsWith(\"Host \") && trimmedLine !== \"Host *\") {\n      if (currentConnection !== null) {\n        connections.push(currentConnection);\n      }\n      currentConnection = { id: connections.length.toString(), address: \"\", name: trimmedLine.substring(5), user: \"\" };\n    } else if (currentConnection !== null) {\n      const firstSpaceIndex = trimmedLine.indexOf(\" \");\n      const key = trimmedLine.substring(0, firstSpaceIndex);\n      const value = trimmedLine.substring(firstSpaceIndex + 1);\n\n      switch (key) {\n        case \"HostName\":\n          currentConnection.address = value;\n          break;\n        case \"User\":\n          currentConnection.user = value;\n          break;\n        case \"Port\":\n          currentConnection.port = value;\n          break;\n        case \"IdentityFile\":\n          currentConnection.sshKey = value;\n          break;\n        case \"HostNameKey\":\n          // Ignore this key\n          break;\n        case \"RemoteCommand\":\n          currentConnection.command = value;\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  if (currentConnection !== null) {\n    connections.push(currentConnection);\n  }\n\n  return connections;\n}\n\nfunction saveSSHConfig(configFilePath: string, connections: ISSHConnection[]): void {\n  let configData = \"\";\n\n  for (const connection of connections) {\n    configData += `Host ${connection.name}\\n`;\n    configData += `  HostName ${connection.address}\\n`;\n\n    if (connection.user) {\n      configData += `  User ${connection.user}\\n`;\n    }\n\n    if (connection.port) {\n      configData += `  Port ${connection.port}\\n`;\n    }\n\n    if (connection.sshKey) {\n      configData += `  IdentityFile ${connection.sshKey}\\n`;\n    }\n\n    if (connection.command) {\n      configData += `  RemoteCommand ${connection.command}\\n`;\n    }\n\n    configData += \"\\n\";\n  }\n\n  fs.writeFileSync(configFilePath, configData.trimEnd());\n}\n\nexport async function getConnections(): Promise<ISSHConnection[]> {\n  switch (sshConfig) {\n    case \"localStorage\": {\n      const { connections } = await LocalStorage.allItems();\n      if (!connections) {\n        return [];\n      }\n      return JSON.parse(connections);\n    }\n    default: {\n      if (!fs.existsSync(sshConfig)) {\n        return [];\n      }\n      const connections = parseSSHConfig(sshConfig);\n      return connections;\n    }\n  }\n}\n\nexport async function saveConnections(connections: ISSHConnection[]) {\n  switch (sshConfig) {\n    case \"localStorage\":\n      await LocalStorage.setItem(\"connections\", JSON.stringify(connections));\n      break;\n    default:\n      saveSSHConfig(sshConfig, connections);\n      break;\n  }\n}\n"],
  "mappings": "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",
  "names": ["show_exports", "__export", "Command", "onlyName", "openIn", "terminal", "__toCommonJS", "import_api", "import_react", "import_node_process", "import_node_util", "import_node_child_process", "execFileAsync", "runAppleScript", "script", "humanReadableOutput", "process", "outputArguments", "stdout", "import_api", "fs", "preferences", "sshConfig", "parseSSHConfig", "configFilePath", "configLines", "connections", "currentConnection", "line", "trimmedLine", "firstSpaceIndex", "key", "value", "saveSSHConfig", "configData", "connection", "getConnections", "saveConnections", "import_jsx_runtime", "preferences", "terminal", "openIn", "onlyName", "runTerminal", "item", "command", "identity", "customPort", "customCommand", "interactive", "address", "scriptWarp", "scriptTerminal", "scriptIterm", "scriptAlacritty", "scriptHyper", "runAppleScript", "error", "getConnectionString", "parts", "Command", "connectionsList", "setConnectionsList", "loading", "setLoading", "items", "getConnections", "removeItem", "i", "saveConnections", "GetAction", "getSubtitle", "onItemRemove", "itemString"]
}
